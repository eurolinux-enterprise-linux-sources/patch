diff -up patch-2.6/aclocal.m4.CVE-2018-1000156 patch-2.6/aclocal.m4
--- patch-2.6/aclocal.m4.CVE-2018-1000156	2009-11-03 13:46:26.000000000 +0100
+++ patch-2.6/aclocal.m4	2018-04-17 10:54:03.732765277 +0200
@@ -38,5 +38,6 @@ m4_include([gl/m4/unlocked-io.m4])
 m4_include([gl/m4/utimbuf.m4])
 m4_include([gl/m4/xalloc.m4])
 m4_include([gl/m4/xstrndup.m4])
+m4_include([gl/m4/tempname.m4])
 m4_include([m4/mkdir.m4])
 m4_include([m4/setmode.m4])
diff -up patch-2.6/configure.ac.CVE-2018-1000156 patch-2.6/configure.ac
--- patch-2.6/configure.ac.CVE-2018-1000156	2009-11-02 20:09:57.000000000 +0100
+++ patch-2.6/configure.ac	2018-04-17 10:54:03.732765277 +0200
@@ -67,6 +67,7 @@ gl_SAFE_WRITE
 gl_STRCASE
 gl_XALLOC
 gl_XSTRNDUP
+gl_FUNC_GEN_TEMPNAME
 
 dnl lib/basename.c requires xstrndup.
 AC_LIBOBJ([xstrndup])
diff -up patch-2.6/gl/lib/tempname.c.CVE-2018-1000156 patch-2.6/gl/lib/tempname.c
--- patch-2.6/gl/lib/tempname.c.CVE-2018-1000156	2018-04-17 10:54:03.732765277 +0200
+++ patch-2.6/gl/lib/tempname.c	2018-04-17 10:54:03.732765277 +0200
@@ -0,0 +1,311 @@
+/* tempname.c - generate the name of a temporary file.
+
+   Copyright (C) 1991-2003, 2005-2007, 2009 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Extracted from glibc sysdeps/posix/tempname.c.  See also tmpdir.c.  */
+
+#if !_LIBC
+# include <config.h>
+# include "tempname.h"
+#endif
+
+#include <sys/types.h>
+#include <assert.h>
+
+#include <errno.h>
+#ifndef __set_errno
+# define __set_errno(Val) errno = (Val)
+#endif
+
+#include <stdio.h>
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMP_MAX
+# define TMP_MAX 238328
+#endif
+#ifndef __GT_FILE
+# define __GT_FILE      0
+# define __GT_DIR       1
+# define __GT_NOCREATE  2
+#endif
+#if !_LIBC && (GT_FILE != __GT_FILE || GT_DIR != __GT_DIR       \
+               || GT_NOCREATE != __GT_NOCREATE)
+# error report this to bug-gnulib@gnu.org
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <sys/time.h>
+#include <stdint.h>
+#include <unistd.h>
+
+#include <sys/stat.h>
+
+#if _LIBC
+# define struct_stat64 struct stat64
+#else
+# define struct_stat64 struct stat
+# define __gen_tempname gen_tempname
+# define __getpid getpid
+# define __gettimeofday gettimeofday
+# define __mkdir mkdir
+# define __open open
+# define __open64 open
+# define __lxstat64(version, file, buf) lstat (file, buf)
+# define __xstat64(version, file, buf) stat (file, buf)
+#endif
+
+#if ! (HAVE___SECURE_GETENV || _LIBC)
+# define __secure_getenv getenv
+#endif
+
+#ifdef _LIBC
+# include <hp-timing.h>
+# if HP_TIMING_AVAIL
+#  define RANDOM_BITS(Var) \
+  if (__builtin_expect (value == UINT64_C (0), 0))                            \
+    {                                                                         \
+      /* If this is the first time this function is used initialize           \
+         the variable we accumulate the value in to some somewhat             \
+         random value.  If we'd not do this programs at startup time          \
+         might have a reduced set of possible names, at least on slow         \
+         machines.  */                                                        \
+      struct timeval tv;                                                      \
+      __gettimeofday (&tv, NULL);                                             \
+      value = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;                      \
+    }                                                                         \
+  HP_TIMING_NOW (Var)
+# endif
+#endif
+
+/* Use the widest available unsigned type if uint64_t is not
+   available.  The algorithm below extracts a number less than 62**6
+   (approximately 2**35.725) from uint64_t, so ancient hosts where
+   uintmax_t is only 32 bits lose about 3.725 bits of randomness,
+   which is better than not having mkstemp at all.  */
+#if !defined UINT64_MAX && !defined uint64_t
+# define uint64_t uintmax_t
+#endif
+
+#if _LIBC
+/* Return nonzero if DIR is an existent directory.  */
+static int
+direxists (const char *dir)
+{
+  struct_stat64 buf;
+  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+/* Path search algorithm, for tmpnam, tmpfile, etc.  If DIR is
+   non-null and exists, uses it; otherwise uses the first of $TMPDIR,
+   P_tmpdir, /tmp that exists.  Copies into TMPL a template suitable
+   for use with mk[s]temp.  Will fail (-1) if DIR is non-null and
+   doesn't exist, none of the searched dirs exists, or there's not
+   enough space in TMPL. */
+int
+__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,
+               int try_tmpdir)
+{
+  const char *d;
+  size_t dlen, plen;
+
+  if (!pfx || !pfx[0])
+    {
+      pfx = "file";
+      plen = 4;
+    }
+  else
+    {
+      plen = strlen (pfx);
+      if (plen > 5)
+        plen = 5;
+    }
+
+  if (try_tmpdir)
+    {
+      d = __secure_getenv ("TMPDIR");
+      if (d != NULL && direxists (d))
+        dir = d;
+      else if (dir != NULL && direxists (dir))
+        /* nothing */ ;
+      else
+        dir = NULL;
+    }
+  if (dir == NULL)
+    {
+      if (direxists (P_tmpdir))
+        dir = P_tmpdir;
+      else if (strcmp (P_tmpdir, "/tmp") != 0 && direxists ("/tmp"))
+        dir = "/tmp";
+      else
+        {
+          __set_errno (ENOENT);
+          return -1;
+        }
+    }
+
+  dlen = strlen (dir);
+  while (dlen > 1 && dir[dlen - 1] == '/')
+    dlen--;                     /* remove trailing slashes */
+
+  /* check we have room for "${dir}/${pfx}XXXXXX\0" */
+  if (tmpl_len < dlen + 1 + plen + 6 + 1)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  sprintf (tmpl, "%.*s/%.*sXXXXXX", (int) dlen, dir, (int) plen, pfx);
+  return 0;
+}
+#endif /* _LIBC */
+
+/* These are the characters used in temporary file names.  */
+static const char letters[] =
+"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
+
+/* Generate a temporary file name based on TMPL.  TMPL must match the
+   rules for mk[s]temp (i.e. end in "XXXXXX", possibly with a suffix).
+   The name constructed does not exist at the time of the call to
+   __gen_tempname.  TMPL is overwritten with the result.
+
+   KIND may be one of:
+   __GT_NOCREATE:       simply verify that the name does not exist
+                        at the time of the call.
+   __GT_FILE:           create the file using open(O_CREAT|O_EXCL)
+                        and return a read-write fd.  The file is mode 0600.
+   __GT_DIR:            create a directory, which will be mode 0700.
+
+   We use a clever algorithm to get hard-to-predict names. */
+int
+__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)
+{
+  int len;
+  char *XXXXXX;
+  static uint64_t value;
+  uint64_t random_time_bits;
+  unsigned int count;
+  int fd = -1;
+  int save_errno = errno;
+  struct_stat64 st;
+
+  /* A lower bound on the number of temporary files to attempt to
+     generate.  The maximum total number of temporary file names that
+     can exist for a given template is 62**6.  It should never be
+     necessary to try all these combinations.  Instead if a reasonable
+     number of names is tried (we define reasonable as 62**3) fail to
+     give the system administrator the chance to remove the problems.  */
+#define ATTEMPTS_MIN (62 * 62 * 62)
+
+  /* The number of times to attempt to generate a temporary file.  To
+     conform to POSIX, this must be no smaller than TMP_MAX.  */
+#if ATTEMPTS_MIN < TMP_MAX
+  unsigned int attempts = TMP_MAX;
+#else
+  unsigned int attempts = ATTEMPTS_MIN;
+#endif
+
+  len = strlen (tmpl);
+  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], "XXXXXX", 6))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* This is where the Xs start.  */
+  XXXXXX = &tmpl[len - 6 - suffixlen];
+
+  /* Get some more or less random data.  */
+#ifdef RANDOM_BITS
+  RANDOM_BITS (random_time_bits);
+#else
+  {
+    struct timeval tv;
+    __gettimeofday (&tv, NULL);
+    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;
+  }
+#endif
+  value += random_time_bits ^ __getpid ();
+
+  for (count = 0; count < attempts; value += 7777, ++count)
+    {
+      uint64_t v = value;
+
+      /* Fill in the random bits.  */
+      XXXXXX[0] = letters[v % 62];
+      v /= 62;
+      XXXXXX[1] = letters[v % 62];
+      v /= 62;
+      XXXXXX[2] = letters[v % 62];
+      v /= 62;
+      XXXXXX[3] = letters[v % 62];
+      v /= 62;
+      XXXXXX[4] = letters[v % 62];
+      v /= 62;
+      XXXXXX[5] = letters[v % 62];
+
+      switch (kind)
+        {
+        case __GT_FILE:
+          fd = __open (tmpl,
+                       (flags & ~O_ACCMODE)
+                       | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
+          break;
+
+        case __GT_DIR:
+          fd = __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);
+          break;
+
+        case __GT_NOCREATE:
+          /* This case is backward from the other three.  __gen_tempname
+             succeeds if __xstat fails because the name does not exist.
+             Note the continue to bypass the common logic at the bottom
+             of the loop.  */
+          if (__lxstat64 (_STAT_VER, tmpl, &st) < 0)
+            {
+              if (errno == ENOENT)
+                {
+                  __set_errno (save_errno);
+                  return 0;
+                }
+              else
+                /* Give up now. */
+                return -1;
+            }
+          continue;
+
+        default:
+          assert (! "invalid KIND in __gen_tempname");
+          abort ();
+        }
+
+      if (fd >= 0)
+        {
+          __set_errno (save_errno);
+          return fd;
+        }
+      else if (errno != EEXIST)
+        return -1;
+    }
+
+  /* We got out of the loop because we ran out of combinations to try.  */
+  __set_errno (EEXIST);
+  return -1;
+}
diff -up patch-2.6/gl/lib/tempname.h.CVE-2018-1000156 patch-2.6/gl/lib/tempname.h
--- patch-2.6/gl/lib/tempname.h.CVE-2018-1000156	2018-04-17 10:54:03.733765282 +0200
+++ patch-2.6/gl/lib/tempname.h	2018-04-17 10:54:03.732765277 +0200
@@ -0,0 +1,50 @@
+/* Create a temporary file or directory.
+
+   Copyright (C) 2006, 2009 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* header written by Eric Blake */
+
+#ifndef GL_TEMPNAME_H
+# define GL_TEMPNAME_H
+
+# include <stdio.h>
+
+# ifdef __GT_FILE
+#  define GT_FILE     __GT_FILE
+#  define GT_DIR      __GT_DIR
+#  define GT_NOCREATE __GT_NOCREATE
+# else
+#  define GT_FILE     0
+#  define GT_DIR      1
+#  define GT_NOCREATE 2
+# endif
+
+/* Generate a temporary file name based on TMPL.  TMPL must match the
+   rules for mk[s]temp (i.e. end in "XXXXXX", possibly with a suffix).
+   The name constructed does not exist at the time of the call to
+   gen_tempname.  TMPL is overwritten with the result.
+
+   KIND may be one of:
+   GT_NOCREATE:         simply verify that the name does not exist
+                        at the time of the call.
+   GT_FILE:             create a large file using open(O_CREAT|O_EXCL)
+                        and return a read-write fd.  The file is mode 0600.
+   GT_DIR:              create a directory, which will be mode 0700.
+
+   We use a clever algorithm to get hard-to-predict names. */
+extern int gen_tempname (char *tmpl, int suffixlen, int flags, int kind);
+
+#endif /* GL_TEMPNAME_H */
diff -up patch-2.6/gl/m4/safe-read.m4.CVE-2018-1000156 patch-2.6/gl/m4/safe-read.m4
--- patch-2.6/gl/m4/safe-read.m4.CVE-2018-1000156	2018-04-17 10:54:03.733765282 +0200
+++ patch-2.6/gl/m4/safe-read.m4	2018-04-17 10:54:03.733765282 +0200
@@ -0,0 +1,18 @@
+# safe-read.m4 serial 5
+dnl Copyright (C) 2002-2003, 2005-2006, 2009 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_SAFE_READ],
+[
+  AC_LIBOBJ([safe-read])
+
+  gl_PREREQ_SAFE_READ
+])
+
+# Prerequisites of lib/safe-read.c.
+AC_DEFUN([gl_PREREQ_SAFE_READ],
+[
+  AC_REQUIRE([gt_TYPE_SSIZE_T])
+])
diff -up patch-2.6/gl/m4/tempname.m4.CVE-2018-1000156 patch-2.6/gl/m4/tempname.m4
--- patch-2.6/gl/m4/tempname.m4.CVE-2018-1000156	2018-04-17 10:54:03.733765282 +0200
+++ patch-2.6/gl/m4/tempname.m4	2018-04-17 10:54:03.733765282 +0200
@@ -0,0 +1,22 @@
+#serial 3
+
+# Copyright (C) 2006-2007, 2009 Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# glibc provides __gen_tempname as a wrapper for mk[ds]temp.  Expose
+# it as a public API, and provide it on systems that are lacking.
+AC_DEFUN([gl_FUNC_GEN_TEMPNAME],
+[
+  AC_REQUIRE([AC_SYS_LARGEFILE])
+
+  AC_LIBOBJ([tempname])
+  gl_PREREQ_TEMPNAME
+])
+
+# Prerequisites of lib/tempname.c.
+AC_DEFUN([gl_PREREQ_TEMPNAME],
+[
+  :
+])
diff -up patch-2.6/Makefile.in.CVE-2018-1000156 patch-2.6/Makefile.in
--- patch-2.6/Makefile.in.CVE-2018-1000156	2009-11-02 20:09:57.000000000 +0100
+++ patch-2.6/Makefile.in	2018-04-17 10:54:30.725902777 +0200
@@ -94,7 +94,8 @@ LIBSRCS = \
 	gl/lib/strncasecmp.c \
 	gl/lib/strndup.c \
 	gl/lib/xmalloc.c \
-	gl/lib/xstrndup.c
+	gl/lib/xstrndup.c \
+	gl/lib/tempname.c
 
 SRCS = $(LIBSRCS) \
 	src/inp.c \
@@ -140,7 +141,8 @@ LIBHDRS = \
 	gl/lib/unlocked-io.h \
 	gl/lib/verify.h \
 	gl/lib/xalloc.h \
-	gl/lib/xstrndup.h
+	gl/lib/xstrndup.h \
+	gl/lib/tempname.h
 
 HDRS = $(LIBHDRS) \
 	src/bestmatch.h \
@@ -209,7 +211,8 @@ TESTS = \
 	tests/reject-format \
 	tests/remember-backup-files \
 	tests/remember-reject-files \
-	tests/unmodified-files
+	tests/unmodified-files \
+	tests/ed-style
 
 BROKEN_TESTS = \
 	tests/dash-o-append
@@ -310,7 +313,8 @@ LIBM4FILES = \
 	gl/m4/unlocked-io.m4 \
 	gl/m4/utimbuf.m4 \
 	gl/m4/xalloc.m4 \
-	gl/m4/xstrndup.m4
+	gl/m4/xstrndup.m4 \
+	gl/m4/tempname.m4
 
 M4FILES = $(LIBM4FILES) \
 	m4/mkdir.m4 \
@@ -384,6 +388,7 @@ gl/lib/getopt.$(OBJEXT) gl/lib/getopt1.$
 gl/lib/hash.$(OBJEXT): $(STDBOOL_H) gl/lib/hash.h
 gl/lib/safe-read.$(OBJEXT): gl/lib/safe-write.h
 gl/lib/safe-write.$(OBJEXT): gl/lib/safe-read.c
+gl/lib/tempname.$(OBJEXT): gl/lib/tempname.h
 
 src/inp.$(OBJEXT): gl/lib/backupfile.h $(COMMON) src/inp.h src/pch.h \
 	gl/lib/quotearg.h src/util.h gl/lib/xalloc.h
diff -up patch-2.6/src/pch.c.CVE-2018-1000156 patch-2.6/src/pch.c
--- patch-2.6/src/pch.c.CVE-2018-1000156	2018-04-17 10:54:03.729765262 +0200
+++ patch-2.6/src/pch.c	2018-04-17 10:54:03.734765287 +0200
@@ -30,6 +30,7 @@
 #undef XTERN
 #define XTERN
 #include <pch.h>
+#include <sys/wait.h>
 
 #define INITHUNKMAX 125			/* initial dynamic allocation size */
 
@@ -2068,21 +2069,30 @@ do_ed_script (FILE *ofp)
     static char const ed_program[] = ed_PROGRAM;
 
     register file_offset beginning_of_this_line;
-    register FILE *pipefp = 0;
     register size_t chars_read;
 
-    if (! dry_run && ! skip_rest_of_patch) {
-	int exclusive = TMPOUTNAME_needs_removal ? 0 : O_EXCL;
-	assert (! inerrno);
-	TMPOUTNAME_needs_removal = 1;
-	copy_file (inname, TMPOUTNAME, 0, exclusive, instat.st_mode, true);
-	sprintf (buf, "%s %s%s", ed_program, verbosity == VERBOSE ? "" : "- ",
-		 TMPOUTNAME);
-	fflush (stdout);
-	pipefp = popen(buf, binary_transput ? "wb" : "w");
-	if (!pipefp)
-	  pfatal ("Can't open pipe to %s", quotearg (buf));
-    }
+    FILE *tmpfp = 0;
+    char const *tmpname;
+    int tmpfd = -1;
+    pid_t pid;
+
+    if (! dry_run && ! skip_rest_of_patch)
+      {
+       /* Write ed script to a temporary file.  This causes ed to abort on
+          invalid commands such as when line numbers or ranges exceed the
+          number of available lines.  When ed reads from a pipe, it rejects
+          invalid commands and treats the next line as a new command, which
+          can lead to arbitrary command execution.  */
+
+       tmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);
+       if (tmpfd == -1)
+         pfatal ("Can't create temporary file %s", quotearg (tmpname));
+       tmpfp = fdopen (tmpfd, "w+b");
+       if (! tmpfp)
+         pfatal ("Can't open stream for file %s", quotearg (tmpname));
+      }
+
+
     for (;;) {
 	char ed_command_letter;
 	beginning_of_this_line = file_tell (pfp);
@@ -2093,14 +2103,14 @@ do_ed_script (FILE *ofp)
 	}
 	ed_command_letter = get_ed_command_letter (buf);
 	if (ed_command_letter) {
-	    if (pipefp)
-		if (! fwrite (buf, sizeof *buf, chars_read, pipefp))
+	    if (tmpfp)
+		if (! fwrite (buf, sizeof *buf, chars_read, tmpfp))
 		    write_fatal ();
 	    if (ed_command_letter != 'd' && ed_command_letter != 's') {
 	        p_pass_comments_through = true;
 		while ((chars_read = get_line ()) != 0) {
-		    if (pipefp)
-			if (! fwrite (buf, sizeof *buf, chars_read, pipefp))
+		    if (tmpfp)
+			if (! fwrite (buf, sizeof *buf, chars_read, tmpfp))
 			    write_fatal ();
 		    if (chars_read == 2  &&  strEQ (buf, ".\n"))
 			break;
@@ -2113,13 +2123,50 @@ do_ed_script (FILE *ofp)
 	    break;
 	}
     }
-    if (!pipefp)
+    if (!tmpfp)
       return;
-    if (fwrite ("w\nq\n", sizeof (char), (size_t) 4, pipefp) == 0
-	|| fflush (pipefp) != 0)
+    if (fwrite ("w\nq\n", sizeof (char), (size_t) 4, tmpfp) == 0
+	|| fflush (tmpfp) != 0)
       write_fatal ();
-    if (pclose (pipefp) != 0)
-      fatal ("%s FAILED", ed_program);
+
+    if (lseek (tmpfd, 0, SEEK_SET) == -1)
+      pfatal ("Can't rewind to the beginning of file %s", quotearg (tmpname));
+
+    if (! dry_run && ! skip_rest_of_patch) {
+       int exclusive = TMPOUTNAME_needs_removal ? 0 : O_EXCL;
+       TMPOUTNAME_needs_removal = 1;
+       if (inerrno != ENOENT)
+         {
+           TMPOUTNAME_needs_removal = 1;
+           copy_file (inname, TMPOUTNAME, 0, exclusive, instat.st_mode, true);
+         }
+       sprintf (buf, "%s %s%s", ed_program,
+                verbosity == VERBOSE ? "" : "- ",
+                TMPOUTNAME);
+       fflush (stdout);
+
+       pid = fork();
+       if (pid == -1)
+         pfatal ("Can't fork");
+       else if (pid == 0)
+         {
+           dup2 (tmpfd, 0);
+           execl ("/bin/sh", "sh", "-c", buf, (char *) 0);
+           _exit (2);
+         }
+       else
+         {
+           int wstatus;
+           if (waitpid (pid, &wstatus, 0) == -1
+               || ! WIFEXITED (wstatus)
+               || WEXITSTATUS (wstatus) != 0)
+             fatal ("%s FAILED", ed_program);
+         }
+    }
+
+    fclose (tmpfp);
+    unlink (tmpname);
+    free ((char*) tmpname);
 
     if (ofp)
       {
diff -up patch-2.6/src/util.c.CVE-2018-1000156 patch-2.6/src/util.c
--- patch-2.6/src/util.c.CVE-2018-1000156	2009-11-02 20:09:57.000000000 +0100
+++ patch-2.6/src/util.c	2018-04-17 10:54:03.734765287 +0200
@@ -45,6 +45,7 @@
 
 #include <stdarg.h>
 #include <full-write.h>
+#include <tempname.h>
 
 static void makedirs (char *);
 
@@ -1217,3 +1218,58 @@ Fseek (FILE *stream, file_offset offset,
   if (file_seek (stream, offset, ptrname) != 0)
     pfatal ("fseek");
 }
+
+#ifndef TMPDIR
+#define TMPDIR "/tmp"
+#endif
+
+int
+make_tempfile (char const **name, char letter, char const *real_name,
+              int flags, mode_t mode)
+{
+  char *template;
+
+  if (real_name)
+    {
+      char *dirname, *basename;
+
+      dirname = dir_name (real_name);
+      basename = base_name (real_name);
+
+      template = xmalloc (strlen (dirname) + 1 + strlen (basename) + 9);
+      sprintf (template, "%s/%s.%cXXXXXX", dirname, basename, letter);
+      free (dirname);
+      free (basename);
+    }
+  else
+    {
+      char const *tmpdir;
+
+      tmpdir = getenv ("TMPDIR");  /* Unix tradition */
+      if (! tmpdir)
+       tmpdir = getenv ("TMP");  /* DOS tradition */
+      if (! tmpdir)
+       tmpdir = getenv ("TEMP");  /* another DOS tradition */
+      if (! tmpdir)
+       tmpdir = TMPDIR;
+
+      template = xmalloc (strlen (tmpdir) + 10);
+      sprintf (template, "%s/p%cXXXXXX", tmpdir, letter);
+    }
+  for(;;)
+    {
+      int fd;
+
+      if (gen_tempname (template, 0, flags, GT_NOCREATE))
+        pfatal ("Can't create temporary file %s", template);
+      fd = open (template, O_CREAT | O_EXCL | flags, mode);
+      if (fd == -1)
+        {
+         if (errno == EEXIST)
+           continue;
+         pfatal ("Can't create temporary file %s", template);
+       }
+      *name = template;
+      return fd;
+    }
+}
diff -up patch-2.6/src/util.h.CVE-2018-1000156 patch-2.6/src/util.h
--- patch-2.6/src/util.h.CVE-2018-1000156	2009-11-02 20:09:57.000000000 +0100
+++ patch-2.6/src/util.h	2018-04-17 10:54:03.734765287 +0200
@@ -71,3 +71,5 @@ void removedirs (char *);
 void set_signals (bool);
 void write_fatal (void) __attribute__ ((noreturn));
 bool file_already_seen (struct stat const *);
+int make_tempfile(char const **, char, char const *, int, mode_t);
+
diff -up patch-2.6/tests/ed-style.CVE-2018-1000156 patch-2.6/tests/ed-style
--- patch-2.6/tests/ed-style.CVE-2018-1000156	2018-04-17 11:00:17.868671087 +0200
+++ patch-2.6/tests/ed-style	2018-04-17 10:59:38.973472959 +0200
@@ -0,0 +1,23 @@
+# Copyright (C) 2018 Free Software Foundation, Inc.
+#
+# Copying and distribution of this file, with or without modification,
+# in any medium, are permitted without royalty provided the copyright
+# notice and this notice are preserved.
+
+. $srcdir/test-lib.sh
+
+require_cat
+use_local_patch
+use_tmpdir
+
+# ==============================================================
+
+cat > ed2.diff <<EOF
+1337a
+r !echo bar
+,p
+EOF
+
+check 'patch -e foo -i ed2.diff > /dev/null 2> /dev/null || echo "Status: $?"' <<EOF
+Status: 2
+EOF
